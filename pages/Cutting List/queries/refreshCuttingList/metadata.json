{
  "gitSyncId": "699387b8cf3d5e4f99911848_cl000001-0000-0000-0000-000000000003",
  "id": "Cutting List_refreshCuttingList",
  "pluginId": "postgres-plugin",
  "pluginType": "DB",
  "unpublishedAction": {
    "actionConfiguration": {
      "body": "TRUNCATE TABLE cutting_list;\n\n-- Build cut items with per-item earliest due date, then rank profile groups\n-- by their earliest due date so the most urgent profile gets cut first.\n-- Within each profile group, cut longest pieces first.\nWITH cut_items AS (\n    SELECT\n        b.timber,\n        b.profile,\n        b.length                               AS bom_length,\n        COALESCE(sp_longer.length, b.length)   AS order_length,\n        SUM(b.qty * pr.qty)                    AS total_qty,\n        ROUND(SUM(\n            b.qty * pr.qty *\n            (SPLIT_PART(b.profile, 'x', 1)::numeric / 1000) *\n            (SPLIT_PART(b.profile, 'x', 2)::numeric / 1000) *\n            (COALESCE(sp_longer.length, b.length)::numeric / 1000)\n        ), 6)                                  AS volume_m3,\n        MIN(COALESCE(o.due_date, so.due_date)) AS earliest_due_date\n    FROM production_runs pr\n    JOIN bom b ON pr.product_no = b.product_no\n    LEFT JOIN orders o\n        ON pr.source_id = o.id AND pr.source_type = 'order'\n    LEFT JOIN standing_orders so\n        ON pr.source_id = so.id AND pr.source_type = 'standing_order'\n    LEFT JOIN stock_profiles sp_exact\n        ON b.timber = sp_exact.timber\n        AND b.profile = sp_exact.profile\n        AND b.length = sp_exact.length\n    LEFT JOIN LATERAL (\n        SELECT length FROM stock_profiles\n        WHERE timber = b.timber AND profile = b.profile AND length > b.length\n        ORDER BY length ASC LIMIT 1\n    ) sp_longer ON sp_exact.id IS NULL\n    LEFT JOIN stock_profiles sp_raw\n        ON b.timber = sp_raw.timber\n        AND b.profile = sp_raw.profile\n        AND sp_raw.length IS NULL\n        AND sp_exact.id IS NULL\n        AND sp_longer.length IS NULL\n    WHERE pr.status = 'Pending'\n        AND sp_exact.id IS NULL\n        AND (sp_longer.length IS NOT NULL OR sp_raw.id IS NOT NULL)\n    GROUP BY b.timber, b.profile, b.length, COALESCE(sp_longer.length, b.length)\n),\n-- Earliest due date for the whole profile group (drives group ordering)\nprofile_priority AS (\n    SELECT timber, profile, MIN(earliest_due_date) AS profile_due_date\n    FROM cut_items\n    GROUP BY timber, profile\n)\nINSERT INTO cutting_list (timber, profile, bom_length, order_length, total_qty, volume_m3, earliest_due_date, sort_order)\nSELECT\n    ci.timber,\n    ci.profile,\n    ci.bom_length,\n    ci.order_length,\n    ci.total_qty,\n    ci.volume_m3,\n    ci.earliest_due_date,\n    ROW_NUMBER() OVER (\n        ORDER BY pp.profile_due_date, ci.timber, ci.profile, ci.bom_length DESC\n    ) AS sort_order\nFROM cut_items ci\nJOIN profile_priority pp ON ci.timber = pp.timber AND ci.profile = pp.profile;",
      "encodeParamsToggle": true,
      "paginationType": "NONE",
      "pluginSpecifiedTemplates": [{ "value": true }],
      "timeoutInMillisecond": 10000
    },
    "confirmBeforeExecute": true,
    "datasource": {
      "id": "Access MRP",
      "isAutoGenerated": false,
      "name": "Access MRP",
      "pluginId": "postgres-plugin"
    },
    "dynamicBindingPathList": [],
    "name": "refreshCuttingList",
    "pageId": "Cutting List",
    "runBehaviour": "MANUAL",
    "userSetOnLoad": false
  }
}
